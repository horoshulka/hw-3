
Выполнила: Хрусталь Варвара
Группа: УИБО-14-24

Цель работы

Изучить основные алгоритмы сортировки и поиска данных, рассмотреть их принципы работы и оценить эффективность с точки зрения временной сложности. Реализовать алгоритмы на языках программирования **Java** и **C++**, сравнить особенности подходов.

Теоретическая часть

Алгоритмы сортировки предназначены для упорядочивания данных по возрастанию или убыванию.
Алгоритмы поиска используются для нахождения конкретного элемента в массиве или списке.
Каждый алгоритм имеет свою область применения, достоинства и недостатки.

 Сортировки

 1. Сортировка выбором (Selection Sort) — *C++*

Алгоритм последовательно выбирает минимальный элемент из неотсортированной части массива и помещает его на соответствующую позицию. Процесс продолжается, пока весь массив не будет упорядочен.
Сложность: O(n²).
Особенности: Простая реализация, но низкая эффективность при большом объёме данных.



 2. Сортировка пузырьком (Bubble Sort) — *C++*

Метод основан на многократном сравнении соседних элементов и обмене их местами, если они расположены неправильно. Каждый проход "всплывает" наибольший элемент в конец массива.
Сложность: O(n²).
Особенности: Один из самых простых, но неэффективных методов. Эффективен на почти отсортированных данных.



 3. Сортировка вставками (Insertion Sort) — *Java*

Массив рассматривается как две части — отсортированная и неотсортированная. Каждый новый элемент вставляется в нужное место среди уже отсортированных элементов.
Сложность: O(n²).
Особенности: Эффективен для небольших массивов и частично отсортированных данных.



 4. Сортировка слиянием (Merge Sort) — *Java*

Массив рекурсивно делится пополам, пока не останутся отдельные элементы, которые затем объединяются в правильном порядке.
Сложность: O(n log n).
Особенности: Один из самых стабильных и надёжных алгоритмов, но требует дополнительной памяти для хранения подмассивов.


 5. Сортировка Шелла (Shell Sort) — *C++*

Усовершенствованный вариант сортировки вставками. Элементы сравниваются и меняются местами на определённом расстоянии (шаге). Постепенно шаг уменьшается до единицы, после чего выполняется окончательная сортировка.
Сложность: около O(n^1.5).
Особенности: Более эффективен, чем простые квадратичные алгоритмы, особенно при больших массивах.



 6. Быстрая сортировка (Quick Sort) — *Java*

Алгоритм выбирает опорный элемент (pivot), делит массив на две части — меньшие и большие элементы относительно него, а затем рекурсивно сортирует эти части.
Сложность: O(n log n) в среднем, O(n²) в худшем случае.
Особенности: Один из самых быстрых алгоритмов на практике, особенно для неравномерных данных.



 7. Пирамидальная сортировка (Heap Sort) — *C++*

Алгоритм основан на структуре данных «куча». Сначала строится максимальная куча, затем наибольший элемент перемещается в конец массива, после чего куча перестраивается.
Сложность: O(n log n).
Особенности: Не требует дополнительной памяти, устойчив в производительности.



 Поисковые алгоритмы

 8. Последовательный (линейный) поиск — *C++*

Проверяет каждый элемент массива по очереди до тех пор, пока не будет найден искомый элемент или не закончится список.
Сложность: O(n).
Особенности: Простой, но неэффективный при большом объёме данных. Применим к неотсортированным массивам.



 9. Бинарный поиск (Binary Search) — *Java*

Работает только с отсортированными массивами. На каждом шаге массив делится пополам, и сравнение производится с серединным элементом.
Сложность: O(log n).
Особенности: Быстрый и эффективный метод для поиска в отсортированных структурах данных.


 10. Интерполирующий поиск (Interpolation Search) — *Java*

Оптимизация бинарного поиска, где позиция для проверки определяется не серединой, а вычисляется на основе значения ключа. Эффективен, если данные распределены равномерно.
Сложность: O(log log n) при равномерных данных, O(n) в худшем случае.
Особенности: Быстрее бинарного при равномерном распределении значений.



 11. Поиск по Фибоначчи (Fibonacci Search) — *C++*

Метод аналогичен бинарному поиску, но границы делятся по числам Фибоначчи. Это помогает оптимизировать количество проверок.
Сложность: O(log n).
Особенности: Использует числа Фибоначчи для определения оптимальной точки разделения массива.




Вывод

В ходе практической работы были изучены и реализованы основные алгоритмы сортировки и поиска данных на языках **Java** и **C++**.
Каждый алгоритм был проанализирован по принципу работы, эффективности и применимости.

Сравнение показало, что:

* Простые алгоритмы (выбором, пузырьком, вставками) удобны для обучения, но не подходят для больших массивов.
* Быстрая, пирамидальная и сортировка слиянием — наиболее эффективные в реальных задачах.
* Среди поисковых алгоритмов наилучшая производительность у бинарного и поиска по Фибоначчи.

